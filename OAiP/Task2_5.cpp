//#include <iostream>
//#include <cstdio>
//#include <conio.h>
//#include <time.h>
//using namespace std;
////я использовал 2 стека: в одном хранил сначала операции, потом символы и их значения, а во втором - только значения(ужже когда считал результат с цифрами
//struct Stack {//второй стек для значений
//	double info;
//	Stack* next;
//};
//struct StackSign {//первый стек для символов и операций
//	char a;
//	double info;
//	StackSign* next;
//};
//double getValue(char t) {//моя функция проверки на не числовой ввод, параметр - символ, результат - double
//	while (true) {//бесконечный цикл, из програмы выйдем return-ом
//		cout << "Enter " << t << " value = ";
//		double x;
//		cin >> x;
//		if (cin.fail()) {//если срабатывает ошибка потока ввода
//			cin.clear();//то возвращаем поток ввода в стандартное состояние
//			cin.ignore(32767, '\n');//и ингорируем все, что было в нем до конца строки потока
//			cout << "Your input is invalid. Please, try again.\n" << endl;//просим повторить
//		}
//		else//если с потоком ввода все ок
//			return x;//просто возвращаем значение
//	}
//}
//Stack* inStack(Stack* p, double in) {//функция добавления в стек: параметры - вершина текущего стека и информация, которую будем вносить, результат - указатель на новую вершину
//	Stack* t = new Stack;//выделяем память под новуй элемент стека
//	t->info = in;//ставим его поле info на in 
//	t->next = p;//его поле next на текущую вершину
//	return t;//возвращаем указатель на новый элемент(новую вершину)
//}
//Stack* outStack(Stack* p, double& out) {//функция изъятия из стека элемента с удалением: параметры - вершина текущего стека и переменная, куда будем доставать(по ссылке) информацию из стека, результат - указатель на новую вершину
//	Stack* t = p;//указатель на вершину текущего стека
//	out = t->info;//достали инфу
//	p = p->next;//переставили вершину стека на следующий элемент
//	delete t;//удалили текущую верщину
//	return p;//вернули новую
//}
//void deleteStack(Stack*& p) {//функция удаления стека: параметр - вершина (по ссылке) 
//	Stack* t;//создаем указатель
//	while (p) {//пока не дошли до конца стека
//		t = p;//устанавливаем t на текущую вершину 
//		p = p->next;//переставляем вершину на следующий элемент
//		delete t;//удаляем старую
//	}
//}
//int prior(char a) {//фукция приоритета: параметры - символ, результат - int
//	switch (a){//выбираем по switch
//		case '*': case '/': return 3;//если символ * или /, вернем из функции 3
//		case '+': case'-': return 2;//если символ + или -, вернем из функции 2
//		case '(': return 1;//если символ (, вернем из функции 1
//	}
//}
//StackSign* inSign(StackSign* p, char a) {//все работает по принципу функции inStack
//	StackSign* t = new StackSign;
//	t->a = a;
//	t->next = p;
//	return t;
//}
//StackSign* outSign(StackSign* p, char& a) {//все работает по принципу функции outStack
//	StackSign* t = p;
//	a = t->a;
//	p = p->next;
//	delete t;
//	return p;
//}
//void deleteSign(StackSign*& p) {//все работает по принципу функции deleteStack
//	StackSign* t;
//	while (p) {
//		t = p;
//		p = p->next;
//		delete t;
//	}
//}
//string checkString(string str) {//параметр - строка(исходная), результат - строка(та же, что и пришла, если она правильная
//	while (true) {//вечный цикл, из которого дельше будем выходить return-ом
//		int a = -1, b = -1, c = 0, d = 0, i = 0;
//		bool k = true;
//		cout << "Enter string: ";
//		cin >> str;
//		for (; str[i]; i++) {
//			if (str[i] == '(') {//проверка на наличие в строке (
//				a = i;//если есть (, то выставляем а на i, которое соответствует последней ( в исходной строке 
//				c++;//если есть (, то увеличиваем счетчик ( на 1
//			}
//			else if (str[i] == ')') {//проверка на наличие в строке ) 
//				b = i;//если есть ), то выставляем b на i, которое соответствует последней ( в исходной строке 
//				d++;//если есть ), то увеличиваем счетчик ) на 1
//			}
//		}
//		i = 0;
//		while (k) {//цикл выполняется, пока k = true
//			if (!str[i])//если str[i] == 0 (или же '\0', то есть дошли до конца строки, то выходим из этого цикла
//				break;
//			else if (((str[i] >= 'a' && str[i] <= 'z') && (str[i + 1] >= 'a' && str[i + 1] <= 'z')) )//если текущий символ в строке буква и следующий за ним тоже буква, то выводим соответствующее сообщение и ставим k = false
//				{
//					cout << "Your input is invalid: you can't input 2 letters one after another. Please, try again.\n" << endl;
//					k = false;
//				}
//			else if ((str[i] == '*' || str[i] == '+' || str[i] == '-' || str[i] == '/')
//				&& (str[i + 1] == '*' || str[i + 1] == '+' || str[i + 1] == '-' || str[i + 1] == '/'))//если текущий символ в строке знак операции и следующий за ним тоже, то выводим соответствующее сообщение и ставим k = false
//			{
//				cout << "Your input is invalid: you can't input 2 signs one after another. Please, try again.\n" << endl;
//				k = false;
//			}
//			else if (b < a || (a < 0 && b >= 0) || (a >= 0 && b < 0) || c != d || (str[i] == '(' && str[i + 1] == ')'))//если текущий символ в строке ( и следующий за ним ), или счетчики скобок не равны, или последняя ( встретилась позже, чем ) , или что-то из а или b < 0, когда другой > 0 (т.е. есть ), но нет ( или  наоборот), то выводим соответствующее сообщение и ставим k = false
//			{
//				cout << "Your input is invalid: fix brackets. Please, try again.\n" << endl;
//				k = false;
//			}
//			else if (str[i] >= '0' && str[i] <= '9')//если текущий символ в строке цифра, то выводим соответствующее сообщение и ставим k = false
//			{
//				cout << "Your input is invalid: you can't use numbers. Please, try again.\n" << endl;
//				k = false;
//			}
//			else if (((str[i] >= 'a' && str[i] <= 'z') && str[i + 1] == '(')
//				|| (str[i] == ')' && (str[i + 1] >= 'a' && str[i + 1] <= 'z')))//если текущий символ в строке буква и следующий за ним сразу ( или текущий ) и следующий за ним сразу буква, то выводим соответствующее сообщение и ставим k = false
//			{
//				cout << "Your input is invalid: you can't input letter and bracket one after another. Please, try again.\n" << endl;
//				k = false;
//			}
//			else if (!((str[i] >= 'a' && str[i] <= 'z') || str[i] == '(' || str[i] == ')'
//				|| str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'))//если текущий символ в строке недопустимый символ (не буква, не (), не операция), то выводим соответствующее сообщение и ставим k = false
//			{
//				cout << "Your input is invalid: you can't use this symbol. Please, try again.\n" << endl;
//				k = false;
//			}
//			i++;
//		}
//		if (k)//если из предыдущего цикла мы вышли, когда дошли до конца строки, то k осталось true => строка правильная, поэтому возвращаем ее как результат функции
//			return str;
//	}
//}
//bool checkSign(StackSign* letters, char a) {//функция проверки наличия буквы в стеке символов: параметры - стек символов, буква, результат - bool
//	while (letters) {//идем до конца стека символов
// 		if (letters->a == a)//если находим в нем символ == букве
//			return false;//то возвращаем false
//		letters = letters->next;//переставляем верщину на следующий символ(со стеком, который мы передаем как параметр, ничего не произойдет, потому что он не по ссылке
//	}
//	return true;//если мы дощли до конца стека и не нашли в нем такой буквы, то возвращаем true
//}
//double inValue(StackSign* t, char str) {//функция нахождения значения, соответствующего данной букве в стеке символов: параметры - стек символов, буква, результат - double
//	for (; t ; t=t->next) {//циклом идем по стеку
//		if (str == t->a)//если нашли в стеке элемент == нашей букве
//			return t->info;//возвращаем из функции значение этого элемента
//	}
//}
//double resultPolandNotation(string str) {//функция расчета значения польской строки с цифрами: параметры - польская строка, результат - double число 
//	double result, value1, value2;
//	StackSign* variables = nullptr, * t;//создаю первый стек символов, в котором будут храниться переменные и их значения  
//	Stack* values = nullptr;//создаю второй стек значений
//	for (int i = 0; str[i]; i++)//идем по польской строке
//		if (str[i] >= 'a' && str[i] <= 'z') {//если текущий символ - буква
//			if(checkSign(variables, str[i]))//вызываем функцию checkSign, чтобы проверить, есть в стеке символов уже такая буква
//				variables = inSign(variables, str[i]);//если такой буквы еще нет, то заносим ее в стек
//		}
//	Link://поставил линку, чтобы прийти сюда через goto, чтобы зациклить прогу
//	cout << "\nEnter values" << endl;
//	for (t = variables; t; t = t->next) {//вводим значения для каждой буквы в получившемся стеке символов 
//		t->info = getValue(t->a);
//	}
//	for (int i = 0; str[i] != '\0'; i++) {//идем по польской строке до конца
//		if (!(str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/'))//если текущий символ - буква 
//			values = inStack(values, inValue(variables, str[i]));//то вносим в стек значений значение, соответствующее этой букве 
//		else {//если текущий элемент операция
//			values = outStack(values, value2);//в переменную value2 достаем последний элемент из стека значений
//			values = outStack(values, value1);//в переменную value1 достаем последний элемент из стека значений
//			switch (str[i]) {//смотрим, какая операция
//			case '+': result = value1 + value2; break;
//			case '-': result = value1 - value2; break;
//			case '*': result = value1 * value2; break;
//			case '/': //с делением сложнее
//				if (value2 != 0) {
//					result = value1 / value2;
//					break;
//				}
//				else {//если value2 == 0
//					cout << "\n\tDivision by zero!!!\nTry with another values" << endl;//делим на ноль
//					deleteStack(values);//очищаем стек значений
//					goto Link;//перехдим о линке, чтобы заново ввести другие значения
//				}
//			}
//			values = inStack(values, result);//в стек значений вносим результат вычисления result
//		}
//	}
//	deleteStack(values);//очищаем стек значений
//	deleteSign(variables);//очищаем стек символов
//	return result;//возвращаем результат
//}
//int main(int argc, char* argv[]) {
//	bool on_off;//это у меня вкл/выкл для зацикливания программы
//	do {
//		on_off = false;//по дефолту он на false
//		StackSign* begin = NULL;//создание стека в котором будем хранить + - / * из исходной строки 
//		string str;//исходная строка
//		char out[81];//строка, в которую будем конвертировать польскую запись
//		int i = 0, j = 0;
//		str = checkString(str);//вызов функции проверки строки на правильность введенных символов
//		while (str[i]) {//идем до конца строки, пока str[i] != '\0'
//			if (str[i] >= 'a' && str[i] <= 'z') {//если в исходной строке буква
//				out[j++] = str[i];//то просто переносим ее в строку вывода, после того, как в out[j] занесется символ j++
//			}
//			else if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') {//если в исходной строке операция, то смотрим на стек операций
//				if (!begin) {//если он пуст, т.е. begin == null
//					begin = inSign(begin, str[i]);//то просто заносим в него текущую операцию
//				}
//				else {//если в стеке операций что-то есть
//					while (begin && prior(begin->a) >= prior(str[i]))//пока приоритет текущей операции в стеке не станет меньше, чем приоритет операции в строке, или пока мы просто не дойдем до конца стека, выгружаем все из него в строку
//						begin = outSign(begin, out[j++]);//выгружаем в out[j], после этого j++ 
//					begin = inSign(begin, str[i]);//текущую операцию из исходной строки заносим в стек
//				}
//			}
//			else if (str[i] == '(') {//если текущий символ (
//				begin = inSign(begin, str[i]);//то просто заносим ее в стек
//			}
//			else if (str[i] == ')') {//если текущий символ в строке )
//				while (begin->a != '(')//выгружаем из стека операций все до (
//					begin = outSign(begin, out[j++]);//выгружаем в out[j], после этого j++ 
//				StackSign* t = begin;//сздаем новый указатель, который ставим на вершину стека (а в ней сейчас '(')
//				begin = begin->next;//переставляем вершину на следующий жлемент стека
//				delete t;//удаляем старую вершину
//			}
//			i++;
//		}
//		//дошли до конца исходной строки 
//		while (begin)//если в стеке операций что-то осталось, то выгружаем все в конец out
//			begin = outSign(begin, out[j++]);
//		out[j] = '\0';//самі добавляем последним сивмолом в строке out нуль-терминатор (признак окончания строки)
//		cout << "\nReverse polish string: " << out << endl;//выводим полученную строку
//		cout << "\nResult: " << resultPolandNotation(out) << endl;//вызываем функцию расчета полученной строки и выводим ее результат
//		cout << "\nDo you want to repeat?(Y/N)" << endl;//спрашиваем, хочет ли пользователь повторить
//		if (_getch() == 'Y' || _getch() == 'y') on_off = true;//если да, то ставим вкл/выкл на true
//	} while (on_off);//выполняем программу, пока on_off = true
//}